# MSC3575: Sliding Sync (aka Sync v3)

This MSC outlines a replacement for the CS API endpoint `/sync`.

The current `/sync` endpoint scales badly as the number of rooms on an account increases. It scales
badly because all rooms are returned to the client, and clients cannot opt-out of a large amount of
extraneous data such as receipts. On large accounts with thousands of rooms, the initial sync
operation can take minutes to perform. This significantly delays the initial login to Matrix clients,
and also makes incremental sync very heavy when resuming after any significant pause in usage.

## Goals

Any improved `/sync` mechanism had a number of goals:
 - Sync time should be independent of the number of rooms you are in.
 - Time from launch to confident usability should be as low as possible.
 - Time from login on existing accounts to usability should be as low as possible.
 - Bandwidth should be minimised.
 - Support lazy-loading of things like read receipts (and avoid sending unnecessary data to the client)
 - Support informing the client when room state changes from under it, due to state resolution.
 - Clients should be able to work correctly without ever syncing in the full set of rooms they’re in.
 - Don’t incremental sync rooms you don’t care about.
 - Combining uploaded filters with ad-hoc filter parameters (which isn’t possible with sync v2 today)
 - Servers should not need to store all past since tokens. If a since token has been discarded we should gracefully degrade to initial sync.
 - Ability to filter by space.
 - Ability to filter by room name.

These goals shaped the design of this proposal. 

## Proposal

At a high level, the proposal introduces a way for clients to filter and sort the rooms they are
joined to and then request a subset of the resulting list of rooms rather than the entire room list.
```
         All joined rooms on user's account
Q W E R T Y U I O P L K J H G F D S A Z X C V B N M
\                                                 /
 \                                               /
  \      Subset of rooms matched by filters     /
   Q W E R T Y U I O P L K J H G F D S A Z X C V
                       |
   A C D E F G H I J K L O P Q R S T U V W X Y Z     Rooms sorted by name (or by recency, etc)
   |_______|
       |

   A C D E F                                         first 5 rooms requested
```
It also introduces a number of new concepts which are explained in more detail later on:
 - Core API: The minimal API to be sliding sync compatible.
 - Extensions: Additional APIs which expose more data from the server e.g presence, device messages
   or additional sort/filter operations.

## Core
A complete sync request looks like:
`POST /_matrix/client/unstable/org.matrix.msc3575/sync?pos=4&timeout=30000`:
```js
{
  // allows clients to know what request params reached the server,
  // functionally similar to txn IDs on /send for events.
  "txn_id": "client-chosen-string",

  // Sliding Window API
  "lists": [
    {
      "ranges": [ [0,99] ],
      "sort": [ "by_notification_level", "by_recency", "by_name" ],
      "required_state": [
        ["m.room.join_rules", ""],
        ["m.room.history_visibility", ""],
        ["m.space.child", "*"]
      ],
      "timeline_limit": 10,
      "filters": {
        "is_dm": true
      }
    }
  ],

  // Room Subscriptions API
  "room_subscriptions": {
      "!sub1:bar": {
          "required_state": [ ["*","*"] ],
          "timeline_limit": 50
      }
  },
  "unsubscribe_rooms": [ "!sub3:bar" ]

  // Extensions API
  "extensions": {}
}
```
An entire response looks like:
`HTTP 200 OK`
```js
{
  // Connection and Streaming API
  "pos": "5",
  "txn_id": "client-chosen-string", // echo of the txn ID

  // Sliding Window API
  "lists": [
    {
      "count": 1337,
      "ops": [
        {
          "op": "SYNC",
          "range": [0, 99]
          "room_ids": [
            "!foo:bar", // ... 99 more room IDs
          ]
        }
      ]
    }
  ],

  // Aggregated rooms from lists and room subscriptions
  "rooms": {
    // Room from room subscription
    "!sub1:bar": {
        "name": "Alice and Bob",
        "initial": true,
        "required_state": [
          {"sender":"@alice:example.com","type":"m.room.create", "state_key":"", "content":{"creator":"@alice:example.com"}},
          {"sender":"@alice:example.com","type":"m.room.join_rules", "state_key":"", "content":{"join_rule":"invite"}},
          {"sender":"@alice:example.com","type":"m.room.history_visibility", "state_key":"", "content":{"history_visibility":"joined"}},
          {"sender":"@alice:example.com","type":"m.room.member", "state_key":"@alice:example.com", "content":{"membership":"join"}}
        ],
        "timeline": [
          {"sender":"@alice:example.com","type":"m.room.create", "state_key":"", "content":{"creator":"@alice:example.com"}},
          {"sender":"@alice:example.com","type":"m.room.join_rules", "state_key":"", "content":{"join_rule":"invite"}},
          {"sender":"@alice:example.com","type":"m.room.history_visibility", "state_key":"", "content":{"history_visibility":"joined"}},
          {"sender":"@alice:example.com","type":"m.room.member", "state_key":"@alice:example.com", "content":{"membership":"join"}}
          {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"A"}},
          {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"B"}},
        ],
        "prev_batch": "t111_222_333",
        "joined_count": 41,
        "invited_count": 1,
        "notification_count": 1,
        "highlight_count": 0
    },
    // rooms from list
    "!foo:bar": {
      "name": "The calculated room name",
      "initial": true,
      "required_state": [
        {"sender":"@alice:example.com","type":"m.room.join_rules", "state_key":"", "content":{"join_rule":"invite"}},
        {"sender":"@alice:example.com","type":"m.room.history_visibility", "state_key":"", "content":{"history_visibility":"joined"}},
        {"sender":"@alice:example.com","type":"m.space.child", "state_key":"!foo:example.com", "content":{"via":["example.com"]}},
        {"sender":"@alice:example.com","type":"m.space.child", "state_key":"!bar:example.com", "content":{"via":["example.com"]}},
        {"sender":"@alice:example.com","type":"m.space.child", "state_key":"!baz:example.com", "content":{"via":["example.com"]}}
      ],
      "timeline": [
        {"sender":"@alice:example.com","type":"m.room.join_rules", "state_key":"", "content":{"join_rule":"invite"}},
        {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"A"}},
        {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"B"}},
        {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"C"}},
        {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"D"}},
      ],
      "prev_batch": "t111_222_333",
      "joined_count": 4,
      "invited_count": 0,
      "notification_count": 54,
      "highlight_count": 3
    },
    // ... 99 more items
  },

  // Extensions API
  "extensions": {}
}
```
These fields and their interactions are explained in the next few sections. This forms the core of
the API. Additional data can be returned via "extensions". 

### Connections

At a high level, the syncing mechanism creates a "connection" to the server to allow the
_bi-directional_ exchange of JSON objects. This mechanism is ideally suited for WebSockets, but more
difficult to do for HTTP long-polling. This design was chosen in order to allow for a seamless transition
to a stream-orientated protocol like WebSockets in the future.

The existing `/sync` implementation in Matrix also creates a stream but it has limitations. It uses
a `since` token to tell clients where in the stream they are and to tell servers which messages the
client has received (in other words it serves as an ACK). Critically, the stream is _not stateful_. The
request must contain the entire set of input parameters, either via a filter ID or in-line filter. This
results in clients using the same set of input parameters most of the time. In order for sliding sync
to provide only the data needed to render the UI and nothing more, the set of input parameters needs to
be greatly expanded and they need to be dynamic: adding and removing parameters on-the-fly, without
additional round trips. In order to achieve this, Sliding Sync creates _stateful_ connections to the
server, so clients can simply send the deltas. This means clients and servers need to have a mechanism
to agree on what that stored state is. _This introduces additional rules on client implementations._

In a WebSockets implementation, this is easy: the request parameters are sent initially when a connection
is established and then remain active for the lifetime of the connection. Any changes to these parameters
are reliably sent to the server in the order they were submitted. In order for clients to know when these
parameters have been applied, most application-level WebSocket protocols use a "message ID" chosen by the
client which is then echoed back in the ACK message. This is very similar to transaction IDs on the `/send`
endpoint in Matrix. 

However, this proposal does not use WebSockets; it uses HTTP long-polling. Like with `/sync`, this proposal
uses a token to allow servers to know which messages the client has received. Emulating WebSockets over HTTP
long-polling is difficult and has limitations. Servers cannot push new data to the client and must instead
wait for the client to make an HTTP request. In addition, individual HTTP requests can fail, resulting in
ordering problems which simply do not exist in a WebSockets implementation. This can lead to some
counter-intuitive responses from a Sliding Sync enabled server, unless certain rules are followed.

**Long-polling Rule 1:** do not send multiple concurrent sliding sync requests to the server. If a request is lost in
transit, it can be impossible to know if it has been applied on the server or not. This is not an issue for `/sync`
because the request is stateless; there's nothing to lose in the event of packet loss. In this example,
A is applied on both sides, B is not applied on either side, and C is applied on one side only, which
then gets returned in the next successful response by using the position of the client request. The
numbers reflect the position in the stream (similar to a `since` token):
```
State  Client               Server   State   position
         | --------A,0------> |                 0
         |                    |        A        1
         | <------OK,1------- |        A        1
  A,1    |                    |        A        1
  A,1    | --------B,1--/     |        A        1
  A,1    | --------C,1------> |        A        1
         |                    |        A,C      2
  A,1    |         /--------- |        A,C      2
         |                    |        A,C      2
  A,1    | --------D,1------> | 1 != 2 -> missed a response
         |                    |        A,C,D    3
A,C,D    | <------C,D,3------ |        A,C,D    3
```
At this point, the client knows that `B` never made it to the server, because C was _sent after_ B, and
the server has ACKed C. If requests were sent in parallel (B and C at the same time), it would be impossible
for clients to know if B was still processing or if B had failed entirely.

**Long-polling Rule 2:** use transaction IDs if you need to know when a response has been applied. The above example used
A,B,C,D as transaction IDs, but in reality requests/responses are not always obviously tied together. For example,
requesting the first 10 rooms on a users account may return 0 results or 10: it's not possible to know ahead of time.
Clients need to know this information to know when to stop showing a spinner for example. For these reasons, clients 
SHOULD send a transaction ID when they need to know when the response has been calculated.

**Long-polling Rule 3:** the HTTP response you receive may not match the HTTP request you sent. In the above example, C,D were
sent in the same response. In practice, the server does not combine multiple responses into a single response. Instead,
it will send the most recent unacknowledged response, in this case C, _even though_ the HTTP request was for D.

#### Message IDs for clients and servers

For the long-polling use case, this proposal includes an opaque token that is very similar to
`/sync` v2's `since` query parameter. This is called `pos` and represents the position in the stream
the client is currently at. Unlike `/sync` v2, this token is ephemeral and can be invalidated at any
time. When a client first connects to the server, no `pos` is specified. Also unlike `/sync` v2, this
token cannot be used with other APIs such as `/messages` or `/keys/changes`. Note that the "connection"
formed to the server is _not_ a long-lived TCP connection, it is just an application-level concept
of a connection.

In simple servers, the `pos` may be an incrementing integer, but more complex servers may use vector
clocks or contain node identifying information in the token. Clients MUST treat `pos` as an opaque
value and not introspect it.

When a `pos` is invalidated and the client attempts to use the `pos`, the server MUST send back a
standard error response as a HTTP 400 containing:
```js
{
  "error": "Unknown position",
  "errcode": "M_UNKNOWN_POS"
}
```
This then allows the client to reset their connection and send an initial request (with all sticky
request parameters) without a `pos` value to restart the connection.

The `timeout` query parameter exists for the same purposes of sync v2: to tell the server how many
milliseconds to hold open the connection before returning.

In addition, clients may send `txn_id` field at the top-level JSON object in the request to serve as
a client message ID. Servers MUST echo this back to the client via the `txn_id` field in the top-level
JSON object in the response when this request has been processed.

_TODO[proxy]: If pos is just an incrementing integer, it means 2 browser tabs with the same access token
will step on each other's toes. The act of hitting /sync without a ?pos results in the first tab being
torn down connection wise. We may want to mux in implicit session IDs into the pos?_

#### Sticky request parameters

Request parameters can be "sticky". This means that their value is remembered across multiple requests.
Clients cannot choose which parameters are sticky, the API defines which parameters are sticky.
The lifetime of sticky request parameters are tied to a sync connection. When the connection is lost,
the request parameters are lost with it. This feature exists to allow clients to configure the sync
stream in a bandwidth-efficient way. For example, if all keys were sticky:
```
Client                         Server
  | ------{ "foo": "bar" }------> |  {"foo":"bar"}
  | <-------HTTP 200 OK---------- |
  | ------{ "baz": "quuz" }-----> | {"foo":"bar","baz":"quuz"}
  | <-------HTTP 200 OK---------- |
```
For complex nested data, APIs which include sticky parameters MUST indicate every sticky field to
avoid ambiguity. For example, an ambiguous API may state the following:
```js
{
    "foo": { // sticky
        "bar": 1,
        "baz": 2
    }
}
```
When this object is combined with an the additional object:
```js
{
    "foo": {
        "bar": 3
    }
}
```
What is the value of `baz`? Both unset and `2` are valid answers. For this reason, `baz` MUST
be marked as sticky if the desired result is `2`, else it will be unset.

In order for servers and clients to agree on the set of sticky parameters, clients MUST send a transaction
ID with each change to their request parameters and servers MUST buffer responses. This transaction ID will
be echoed back to the client so it knows that those parameters have been applied. If the request parameters
have not been modified, then the `txn_id` does not need to be sent.

### Room List parameters

One or more room lists can be requested in sliding sync like so:
```js
{
  "lists": [
    {
      // Sliding window ranges, see the Sliding Window API for more information.
      // If this field is missing, no sliding window is used and all rooms are returned in this list.
      "ranges": [ [0,99] ],
      // Sticky. List sort order. See Sliding Window API for more information.
      // These fields may be expanded through use of extensions.
      "sort": [ "by_notification_level", "by_recency" ],

      // Sticky. Required state for each room returned. An array of event type and state key tuples.
      // Note that elements of this array are NOT sticky so they must be specified in full when they
      // are changed.
      "required_state": [
        // Request the join rules event. Note that the empty string is required here to match
        // the event's blank state_key.
        ["m.room.join_rules", ""],
        ["m.room.history_visibility", ""],
        // Request all `m.room.member` state events.
        // The * is a special sentinel value meaning 'all keys'.
        // Note that `*` is NOT a generic glob function. You cannot specify `foo*` to pull in keys
        // like `food` and `foobar`. In this case, the * is treated as a literal *.
        ["m.room.member", "*"]
        // Request all state events.
        ["*", "*"]
      ],
      // Sticky. The maximum number of timeline events to return per response.
      "timeline_limit": 10,
      // Sticky. Filters to apply to the list before sorting.
      "filters": {
        // All fields below are Sticky.
        // All fields are applied with AND operators, hence if is_dm:true and is_encrypted:true
        // then only Encrypted DM rooms will be returned. The absence of fields implies no filter
        // on that criteria: it does NOT imply 'false'.
        // These fields may be expanded through use of extensions.

        // Flag which only returns rooms present (or not) in the DM section of account data.
        // If unset, both DM rooms and non-DM rooms are returned. If false, only non-DM rooms
        // are returned. If true, only DM rooms are returned.
        "is_dm": true,
        // A list of spaces which target rooms must be a part of, as m.space.child state events.
        // The server will inspect the m.space.child state events for the JOINED space room IDs given,
        // and filter the room list based on the INVITED/JOINED children room IDs.
        // If the child room has a m.room.tombstone event, then the search should recursively navigate
        // the room ID in that event to find the latest room and use that room ID instead of the initial
        // room ID in the m.space.child event.
        // If unset, all rooms are included. Servers MUST NOT navigate subspaces. It is up to the client to
        // give a complete list of spaces to navigate. Only rooms directly mentioned as m.space.child
        // events in these spaces will be returned. Unknown spaces or spaces the user is not joined to
        // will be ignored.
        "spaces": ["!foo:bar", "!bar:baz"],
        // Flag which only returns rooms which have an `m.room.encryption` state event. If unset,
        // both encrypted and unencrypted rooms are returned. If false, only unencrypted rooms
        // are returned. If true, only encrypted rooms are returned.
        "is_encrypted": true,
        // Flag which only returns rooms the user is currently invited to. If unset, both invited
        // and joined rooms are returned. If false, no invited rooms are returned. If true, only
        // invited rooms are returned.
        "is_invite": true,
        // Flag which automatically walks over tombstoned rooms to the most recent room. For example,
        // if a DM room is upgraded, the old tombstoned room will NOT be returned but the new room will
        // be returned instead, regardless of whether the new room is present in the DM section of account
        // data or not. If there is no newer room (e.g the user hasn't joined it yet) then the tombstoned
        // room will be returned as it is the most recent room for that client. Room metadata which affects
        // filters pass through transitively. For example, if there are a series of room upgrades A -> B -> C
        // and only B is in the DM map, then C is treated as being in the same DM map. The specific metadata
        // fields which are considered in this way are fields which are pinned to a static room ID:
        // - DM rooms in account data.
        // - Space children/parents.
        // - Tagged rooms e.g favourites.
        "resolve_tombstones": true,
        // If specified, only rooms where the `m.room.create` event has a `type` matching one
        // of the strings in this array will be returned. If this field is unset, all rooms are
        // returned regardless of type. This can be used to get the initial set of spaces for an account.
        // For rooms which do not have a room type, use 'null' to include them.
        "room_types": [ "m.space", null ],
        // Same as "room_types" but inverted. This can be used to filter out spaces from the room list.
        // If a type is in both room_types and not_room_types, then not_room_types wins and they are
        // not included in the result.
        "not_room_types": [ "m.space" ],
        // Filter the room name. Case-insensitive partial matching e.g 'foo' matches 'abFooab'.
        // The term 'like' is inspired by SQL 'LIKE', and the text here is similar to '%foo%'.
        "room_name_like": "foo",
        // Filter the room based on its room tags. If multiple tags are present, a room can have
        // any one of the listed tags (OR'd).
        "tags": ["m.favourite"],
        // Filter the room based on its room tags. Takes priority over `tags`. For example, a room
        // with tags A and B with filters tags:[A] not_tags:[B] would NOT be included because not_tags
        // takes priority over `tags`. This filter is useful if your Rooms list does NOT include the
        // list of favourite rooms again.
        "not_tags": ["m.lowpriority"]
      }
    }
  ],
}
```

_Rationale: There are use cases for clients requesting multiple lists. Many clients have DMs and
Invites in dedicated sections separate from the joined room list. API support for this is important
to ensure that the initial UI can load quickly. This is why the API allows multiple lists and there
are filters for things like DMs, Invites and Spaces. The timeline limit is very similar to Sync v2's
`room.timeline.limit` filter field and is required to ensure that busy rooms don't send vast amounts
of events. Wildcard matching on `required_state` fields are purposefully restricted to avoid clients
sending complex matching criteria (e.g pathological regular expressions) and in practice there seems
to be very little in-the-wild use of partial key matching like `foo*` as new state events tend to
namespaced by their event type. Fields in `required_state` are not sticky mainly due to semantics:
expressing deletions becomes hard. The inclusion of a dedicated `is_encrypted` filter exists for the
benefit of complex clients: see the E2EE section for more information. The `room_name_like` field
exists to allow the ability to search by room name which most clients support, and is crucial for
large accounts. The `room_types` filters exist primarily to include/exclude spaces. The
`resolve_tombstones` flag exists to remove tombstoned rooms from the sync response: clients would be
filtering these rooms out anyway, so rather save on the bandwidth! It's slightly more complicated than
that as sometimes we do want to return a tombstoned room to the user if they haven't joined the upgraded
room yet, and this chain of tombstoned rooms has implications on filtering, hence why this is "resolving"
tombstones and not just `is_tombstoned`._

The server will then return a `rooms` key which have the following fields:

```js
{
  "rooms": {
    // the room ID
    "!foo:bar": {
      "name": "The calculated room name",
      // Flag which is set when this is the first time the server is sending this data on this connection.
      // Clients can use this flag to replace or update their local state. When there is an update, servers
      // MUST omit this flag entirely and NOT send "initial":false as this is wasteful on bandwidth. The
      // absence of this flag means 'false'.
      "initial": true,
      // this is the CURRENT STATE, unlike sync v2
      "required_state": [
        {"sender":"@alice:example.com","type":"m.room.join_rules", "state_key":"", "content":{"join_rule":"invite"}},
        {"sender":"@alice:example.com","type":"m.room.history_visibility", "state_key":"", "content":{"history_visibility":"joined"}},
        {"sender":"@alice:example.com","type":"m.space.child", "state_key":"!foo:example.com", "content":{"via":["example.com"]}},
        {"sender":"@alice:example.com","type":"m.space.child", "state_key":"!bar:example.com", "content":{"via":["example.com"]}},
        {"sender":"@alice:example.com","type":"m.space.child", "state_key":"!baz:example.com", "content":{"via":["example.com"]}}
      ],
      // Last event is most recent. Max timeline_limit events.
      "timeline": [
        {"sender":"@alice:example.com","type":"m.room.join_rules", "state_key":"", "content":{"join_rule":"invite"}},
        {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"A"}},
        {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"B"}},
        {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"C"}},
        {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"D"}},
      ],
      "is_dm": true, // field is absent on non-DM rooms
      "invite_state": [ { type: "m.room.member" } ], // stripped state events, same as rooms.invite.$room_id.invite_state in sync v2, absent on joined/left rooms
      "prev_batch": "t111_222_333", // same as sync v2
      "limited": true,              // same as sync v2
      "joined_count": 41,           // same as sync v2 m.joined_member_count
      "invited_count": 1,           // same as sync v2 m.invited_member_count
      "notification_count": 54,     // same as sync v2
      "highlight_count": 3          // same as sync v2
    }
  }
}
```

_Rationale: The room name and counts are required for display on the UI. They are calculated server
side because they are required for sort operations on lists. The joined and invited member counts are
included for the client-side calculation of push rules, specifically `{"kind":"room_member_count","is":"2"}`
which would be impossible to calculate without knowing the total number of users in the room. Failure
to include this field could cause rooms to notify incorrectly, and they need to be calculated client-side
in E2EE rooms. The `required_state` is controversially
the **current state** which breaks from sync v2 which has the `state` be "the state before the start
of the timeline". Sync v2's rationale was event duplication (state events can appear in both the
state section and the timeline section if it's the current state) and the fact that clients would have
to rewind state to work out historical display names. Clients who show historical display names
already need to rewind state by inspecting the `prev_content` of an event to display text like
"@alice changed their name from Alice to Alice2". Event duplication may be
reduced using Event ID -> Event maps in the response should this be a concern. The benefit of
returning the current state is that servers can cache the latest state to return the response more
quickly. If, instead, servers returned the state at the start of a timeline block, servers are forced
to either rewind this state (as clients will need to do) or worse, do an expensive database access to
request the state before an event. As clients can be at different points in the stream for a given
room, this would force servers to cache every possible room state. It's not practical for servers to
cache every single possible earlier state for each room._

TODO: There is currently no lazy-loaded members support. Various suggestions like a special sentinel
value in required state e.g `["m.room.member", "LAZY"]` could be used. This may need to be specified
in this MSC or possibly an extension MSC (though it's unclear how it would fall under the filtering 
extension MSC format). For context, lazy-loaded members refers to the sending of `m.room.member`
events for the _senders_ of the events that are present in `timeline`. Current implementations use
a LRU cache to cut down on sending duplicate events. In addition, we may also want a sentinel value
to indicate "the current user" e.g to always pull out the current user's member event
`["m.room.member", "$current"]`. Are there any other interesting state filters?

### Sliding Window API

At a high level, the sliding window API provides a way to synchronise a subslice of a list in a
bandwidth efficient way. It does this by referring to "operations" which must be performed on the
stored client list, such as INSERT, DELETE and SYNC. Each operation has an index position OR a
range of index positions which tells the client where the operation should be performed. The
possible operations are:
 - `SYNC`: Sets a *range* of entries. Clients SHOULD discard what they previous knew about entries in
   this range.
 - `INSERT`: Sets a *single* entry. If the position is not empty then clients MUST move entries
   to the left or the right depending on where the closest empty space is.
 - `DELETE`: Remove a *single* entry. Often comes before an `INSERT` to allow entries to move places.
 - `INVALIDATE`: Remove a *range* of entries. Clients MAY persist the invalidated range for offline
   support, but they should be treated as empty when additional operations which concern indexes in
   the range arrive from the server.


For example:
```
            Client                         Server
          []  |                              |  0,1,2,3,4,5,6,7,8   index
              |                              | [A,B,C,D,E,F,G,H,I]
              | -------- range[0,4] -------> |
 [A,B,C,D,E]  | <--- SYNC[0,4]=A,B,C,D,E --- |
              |                              |  0,1,2,3,4,5,6,7,8
              |                              | [H,A,B,C,D,E,F,G,I]  H moves to the front
              | ----- wait for updates ----> |
 [H,A,B,C,D]  | <- DELETE[4], INSERT[0]=H--- |
              |                              |  0,1,2,3,4,5,6,7,8
              |                              | [J,K,L,M,N,O,P,Q,R]  Entire list is replaced
              | ----- wait for updates ----> |
 [J,K,L,M,N]  | <----INVALIDATE[0,4]-------- |
              |      SYNC[0,4]=J,K,L,M,N     |
              |                              | [J,K,L,N,O,P,Q,R]    M is deleted
              | ----- wait for updates ----> |
 [J,K,L,N,O]  | <- DELETE[3], INSERT[4]=O--- |
```
The sliding sync API exposes this API shape via the following request parameters:
```js
{
  // Multiple lists can be requested
  "lists": [
    {
      // Multiple sliding windows inside a list can be requested. Integers are _inclusive_.
      "ranges": [ [0,9], [20,29] ],
      // How the list should be sorted on the server. The first value is applied first, then tiebreaks
      // are performed with the 2nd sort order, then the 3rd until there are no more sort orders left.
      "sort": [ "by_notification_level", "by_recency", "by_name" ],
      // Additional Room List request parameters omitted as they are
      // unrelated to the semantics of the sliding window, see previous section.
    }
  ],
}
```
Which returns the following response parameters:
```js
{
  // This array is exactly the same length as the `lists` provided in the request. All lists MUST
  // return at the very least a `count`, even if there are no changes to the list.
  "lists": [
    // List 0
    {
      // The total number of entries in the list. Always present.
      "count": 1337,
      // The sliding list operations to perform.
      "ops": [
        {
          // The operation being performed.
          "op": "SYNC",
          // Which index positions are affected by this operation. These are both inclusive.
          "range": [0, 9],
          // Which room IDs are affected by this operation. These IDs match up to the positions
          // in the `range`, so the last room ID in this list matches the 9th index. The room data
          // is held in a separate object.
          "room_ids": [
            "!foo:bar", // ... 9 more room IDs
          ]
        }
      ]
    }
  ],
  // The room data to use for each room ID. This data represents the point in time AFTER all
  // ops have been applied. For example, if a room had 2 new events which changed its list position
  // then you could see `ops` with DELETE[4,!foo:bar], INSERT[0,!foo:bar], DELETE[0,!foo:bar], INSERT[1,!foo:bar]
  // then the room !foo:bar in this map MUST contain both events.
  //
  // This map will only contain rooms which are present in the list `ops` above. If there are no
  // `ops` (because there are no `ranges`) then all rooms which match the list filters will be
  // present in this list, unordered. This functionality is useful for clients which do not want
  // to use sliding list semantics. This map is an aggregation of all rooms which can be returned
  // over all lists, including room subscriptions. This means if a room appears in 2 lists, only
  // 1 entry is present.
  "rooms": {
    "!foo:bar": {
      "name": "The calculated room name",
      // Additional response parameters omitted as they are
      // unrelated to the semantics of the sliding window.
      // See previous section on room list parameters.
    },
    // ... 9 more items
  },
}
```

_Rationale: Prior versions of this MSC more tightly coupled room data and list operations. This
became a problem if you did not want to use sliding windows because the room data will be contained
within list operations you don't care about. Now that this data is split out, it is easy for clients
to opt-out of sliding window semantics entirely (the `ops` key just disappears). Furthermore, the
`rooms` map was originally split out to be per-list / per-room-subscription but this could cause
needless duplication if a room appeared in >1 list. Each list can have different parameters associated
with them (e.g `required_state`, `timeline_limit`) but these can be aggregated / UNION'd easily._

The possible `sort` operations are:
 - `by_recency`: Sort by `origin_server_ts` on the most recently _received_ event in the room. Note
   that due to clock drift over federation it is possible for rooms to re-order such that the most
   recently received event in the entire list does not cause that room to go to index position 0.
   The highest `origin_server_ts` value comes first in the list.
 - `by_notification_level`: Sort based on the presence of non-zero values for `highlight_count` and
   `notification_count`. Rooms with a `highlight_count` > 0 come first, followed by rooms with a
   `notification_count` > 0, followed by all other rooms. Rooms are not sorted within each level:
   use an additional sort operation like `by_recency` to sort these groups. TODO: should we include
   unread indicator with this?
 - `by_name`: Sort by room name lexicographically. This requires servers to implement the
   [room name calculation algorithm](https://matrix.org/docs/spec/client_server/latest#calculating-the-display-name-for-a-room).
   The server MUST perform the following steps:
     * Calculate the room name from this user's perspective. This may vary depending on the user as
       DM rooms will have the room name set to the name of the _other user_. This is the value that
       will be returned in the `name` field for the room but is NOT the value that the server should
       perform sort operations on. See following steps.
     * Remove any of the following characters from the beginning/end of the calculated name: `#!()):_@`.
       This ensures things like canonical aliases display in roughly the right alphabetical locations
       rather than all together with all rooms that start with `#`.
     * Lower-case the result by unicode. This ensures `Matrix` and `matrix` sort in the same locations.
     * Perform sort operations on this 'canonicalised' name. For clarity, the sort is descending so
       `A` comes before `B`.

Sorting algorithms MUST be stable and deterministic to avoid needless churn as otherwise identical
rooms keep swapping positions. This can easily be achieved by including a final tiebreak based on the
room ID (e.g lexicographical sort on the room ID) to guarantee stability and determinism. It is currently
_not possible_ to invert the sort order (ASC vs DESC). This may be added to this MSC if there is a
community need for it.

NOTE: It is known that by forcing servers to calculate the room name there can be problems concerning
multiple languages. "Alice and Bob" in English vs "Alice et Bob" in French for example, which may affect
sort ordering. This can be mitigated by adding a `lang` sticky request parameter to control how
i18n and l10n are done.

_Rationale: The sort operations are restrictive and limited in scope on purpose. Alternatives such
as arbitrary or more expansive sort orders were decided against as it would A) force servers to support
nonsensical and potentially expensive operations and B) not produce the best sort order for specific
use cases in Matrix such as alias handling. That being said, having some mechanism to support
additional sort operations is useful, see the extensions section for more information._

The complete API shape for each operation is shown below (note the key names vary on the operation):

```js
{
  "op": "DELETE",
  "index": 8
}

{
  "op": "INSERT",
  "index": 99,
  "room_id": "!foo:bar"
}

{
  "op": "INVALIDATE",
  "range": [100,199]
}

{
  "range": [100,117],
  "op": "SYNC",
  "room_ids": [
    // ... 18 room IDs
  ]
}
```

Note that clients will NOT be notified of any events or activity in rooms not in the sliding window.
This can be a problem for some use cases:
 - Following a permalink to a random room which is not in the window should be possible.
 - Receiving a direct @mention in a room not in the window should notify the client.

For the first of these issues, the sliding sync API exposes a "room subscription" API. For the second issue,
the sliding sync API exposes a "notifications" API.

#### Requesting all rooms

Sometimes clients may not wish to deal with sliding windows, and instead get all rooms on the user's account.
For example, if your client is a bot or an application service, having sliding windows just adds extra complexity.
To aid these use cases, any list can omit the `ranges` key and add a new sticky key at the same level:
`slow_get_all_rooms: true`. If this is set, the `ranges` and `sort` keys are ignored and all rooms which match the list
`filters` will be returned. If there are no filters for this list, then all rooms on the user's account will
be returned. This gives additional flexibility as it allows clients to request all E2EE rooms in a separate list
from the sliding windows. When operating in this mode, there will be no movement operations (DELETE followed by INSERT)
as the client has the entire list and can work out whatever sort order they wish. There will still be DELETE
and INSERT operations when rooms are left or joined respectively. In addition, there will be an initial SYNC
operation to let the client know which rooms in the `rooms` object were from this list.

An example request:
```js
{
  "lists": [
    // list 0 will include all encrypted rooms in one go
    {
      "slow_get_all_rooms": true,
      "filters": {
        "is_encrypted": true
      }
    },
    // list 1 will include the first 20 unencrypted rooms sorted accordingly
    {
      "ranges": [ [0,19] ],
      "sort": [ "by_notification_level", "by_recency" ],
      "filters": {
        "is_encrypted": false
      }
    }
  ],
}
```
Would return the response:
```js
{
  "lists": [
    {
      "count": 1337,
      "ops": [
        {
          "op": "SYNC",
          "range": [0, 1336],
          "room_ids": [
            "!encrypted:bar", // ... 1336 more room IDs
          ]
        }
      ]
    },
    {
      "count": 420,
      "ops": [
        {
          "op": "SYNC",
          "range": [0, 19],
          "room_ids": [
            "!unencrypted:bar", // ... 19 more room IDs
          ]
        }
      ]
    }
  ],
  "rooms": {
    "!encrypted:bar": {
      ...
    },
    // ... 1336 more items
    "!unencrypted:bar": {
      ...
    },
    // ... 19 more items
  },
}
```


### Room Subscription API

Sometimes clients know exactly which room they want to get information about e.g by following a
permalink or by refreshing a webapp currently viewing a specific room. The sliding window API alone
is insufficient for this use case because there's no way to say "please track this room explicitly".
The room subscription API serves as a way to provide this tracking. At a high level, the client
provides a map of room ID to room list parameters and the server then returns the response in the
same format as the sliding window API, just without the operations/indexes.

To track a room `!sub1:bar`, the client would send the following request:
```js
{
  "room_subscriptions": { // sticky
      "!sub1:bar": { // sticky
          "required_state": [ ["*","*"] ],
          "timeline_limit": 50
      }
  }
}
```
This would return the following response:
```js
{
  "rooms": {
    "!sub1:bar": {
        "name": "Alice and Bob",
        "required_state": [
          {"sender":"@alice:example.com","type":"m.room.create", "state_key":"", "content":{"creator":"@alice:example.com"}},
          {"sender":"@alice:example.com","type":"m.room.join_rules", "state_key":"", "content":{"join_rule":"invite"}},
          {"sender":"@alice:example.com","type":"m.room.history_visibility", "state_key":"", "content":{"history_visibility":"joined"}},
          {"sender":"@alice:example.com","type":"m.room.member", "state_key":"@alice:example.com", "content":{"membership":"join","displayname":"Alice"}},
          {"sender":"@alice:example.com","type":"m.room.member", "state_key":"@bob:example.com", "content":{"membership":"join","displayname":"Bob"}}
        ],
        "timeline": [
          {"sender":"@alice:example.com","type":"m.room.create", "state_key":"", "content":{"creator":"@alice:example.com"}},
          {"sender":"@alice:example.com","type":"m.room.join_rules", "state_key":"", "content":{"join_rule":"invite"}},
          {"sender":"@alice:example.com","type":"m.room.history_visibility", "state_key":"", "content":{"history_visibility":"joined"}},
          {"sender":"@alice:example.com","type":"m.room.member", "state_key":"@alice:example.com", "content":{"membership":"join","displayname":"Alice"}},
          {"sender":"@alice:example.com","type":"m.room.member", "state_key":"@bob:example.com", "content":{"membership":"join","displayname":"Bob"}}
          {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"A"}},
          {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"B"}},
        ],
        "limited": true,
        // ...
    }
  }
}
```

Any updates in this room would be returned in the same section of the sync response:

```js
{
  "rooms": {
    "!sub1:bar": {
        "timeline": [
          {"sender":"@alice:example.com","type":"m.room.message", "content":{"body":"C"}},
        ]
    }
  }
}
```

Multiple rooms can be subscribed to by specifying additional keys in the room subscription map. If
a room is subscribed to multiple times, the _most recent_ subscription takes effect for the purposes
of `required_state` and `timeline_limit` filtering.

To unsubscribe from a room, the client needs to send a request with the room ID to unsubscribe from in
the `unsubscribe_rooms` array:
```js
{
  "unsubscribe_rooms": [ "!sub1:bar" ]
}
```
This will delete that key from the `room_subscriptions` map on the server. It is common to for clients
to view one room then swap to another room. This can be modelled as a subscription on the new room
coupled with unsubscribing from the old room. For example, if the client swapped from viewing
`!sub1:bar` to `!sub2:bar`:
```js
{
  "room_subscriptions": {
      "!sub2:bar": {
          "required_state": [ ["*","*"] ],
          "timeline_limit": 50
      }
  }
  "unsubscribe_rooms": [ "!sub1:bar" ]
}
```

`unsubscribe_rooms` is cleared after every response; it is not sticky.

_Rationale: By using a map, this supports clients who can show multiple room timelines in the UI e.g
Hydrogen's grid view. The `unsubscribe_rooms` array allows rooms to be efficiently deleted from the
map. An alternative would be to specify an empty JSON object in the room subscription but that feels
less explicit than the array form._

### Commonalities between the Room Subscription API and Sliding Window API

In the request, both the sliding window API and the room subscription API use the same keys to extract room data. Both
APIs also return that room data in the same part of the response. These keys are:

 - `required_state`: Required state for each room returned. An array of event type and state key tuples.
 - `timeline_limit`: The maximum number of timeline events to return per response.

_All_ room data is returned in a top-level `rooms` keys in the response JSON, regardless of whether
this room is being returned due to it being a room subscription or in a list. This de-duplicates data
when a room can be present in more than 1 list. However, multiple lists may have different values for
`required_state` or `timeline_limit`. In this case, these values are combined together according to
the following rules:

 - `required_state`: Combine all arrays and treat it as a single unified array.
 - `timeline_limit`: Take the highest value.

 Due to this, clients need to take care to extract only the number of timeline events / state events
 they require from the `rooms` response, as it may include more data than they requested in a single
 list.


### Notifications API

If you are tracking the top 5 rooms and an event arrives in the 6th room, you will be notified about
the event ONLY IF the sort order means the room bumps into the top 5. If for example you sorted
`by_name` then you won't be notified about the event in the 6th room, unless it's an `m.room.name`
event which moves the room into the top 5. In most "recent" sort orders a new event *will result* in
the 6th room bumping to the top of the list. A notable exception is when the rooms are sorted in
*alphabetical order* (`by_name`), which is what some other chat clients do for example. In this case,
you don't care about the event unless the event is a "highlightable" event (e.g direct @mention).
The notifications API exists to provide a mechanism for clients to display "unread messages"
indicators on the room list at positions not currently inside a sliding window.

TODO:
- Unsure how much data to expose (probably index position + notif/highlight counts?). If we do _counts_
then we are doomed to send a response to a client every time an event is sent in a noisy room, which
seems rather wasteful. Perhaps make it configurable? @timokoesters mentions having approx counts to
avoid the churn e.g only two digits of precision (21 -> 21, but 1234 -> 1200), this fits UIs very nicely.
- This has not been fully specced yet because in practice most clients sort by recency so it's not
  urgent to include this. For clients who sort by name though, this is a show stopper.

### Bandwidth optimisations for persistent clients

The API assumes that room data is deleted on the client when the room falls out of the sliding
window or a window gets invalidated. The API will send the entire `required_state` and `timeline`
again when the room re-appears. This is wasteful if the client remembers the state/timeline and there
have been no changes. This is similar to how Sync v2 behaves with `?full_state=true` set.

The API exposes an opt-in mechanism for providing efficient delta updates. On re-establishing a sync
connection, or re-requesting a page that was previously INVALIDATEd, the server will perform the
following operations:
 - For this device: check the last sent event ID for the room ID in question. Count the number of
   timeline events from that point to the latest event. Call it `N`.
 - For this specific sync request: calculate a reasonable upper-bound for how many events will be
   returned in a reasonable worst-case scenario. This is simply `timeline_limit + len(required_state)`
   (ignoring `*` wildcards on state). Call it `M`.
 - If N > M then we would probably send more events if we did a delta than just telling the client
   everything from scratch, so issue a `SYNC` for this room.
 - If N < M then we don't have many events since the connection was last established, so just send
   the delta as an update.

This approach has numerous benefits:
 - In the common case when you scroll a room, you won't get any `SYNC`s for rooms that were invalidated
   because it's highly unlikely to receive 10+ events during the room scroll (assuming you scroll
   back up in reasonable time).
 - When you reconnect after sleeping your laptop overnight, most rooms will be updates, and busy
   rooms like Matrix HQ will be `SYNC`ed from fresh rather than sending 100s of events.

This imposes more restrictions on the server implementation:
 - Servers still need the absolute stream ordering for events to work out how many events from
   `$event_id` to `$latest_event_id`.
 - Servers need to remember the last sent event ID for each device for each room. If rooms share a
   single monotonically increasing stream, then this is a single integer per device (akin to today's
   sync tokens for PDU events). Servers need to remember _which rooms_ have been sent to the client,
   along with the stream position when that was sent. So it's basically a `map[string]int64`.


### E2EE Handling

The server cannot calculate the `highlight_count` in E2EE rooms as it cannot read the message content.
This is a problem when clients want to sort by `highlight_count`. In comparison, the server can
calculate the name, `unread_count`, and work out the most recent timestamp when sorting by those
fields. What should the server do when the client wants to sort by `highlight_count` (which is pretty
typical!)? It can:
 - Assume `highlight_count == 1` whenever `unread_count > 0`. This ensures that E2EE rooms are always
   bumped above unreads in the list, but doesn't allow sorting within the list of highlighted rooms.
 - Assume `highlight_count == 0` always. This will always sort E2EE rooms below the highlight list,
   even if the E2EE room has a @mention.
 - Sort E2EE rooms in their own dedicated list: `{"filters": { "is_encrypted": true }}`

In all cases, the client needs to do additional work to calculate the `highlight_count`. When the
client is streaming this work is very small as it just concerns a single event. However, when the
client has been offline for a while there could be hundreds or thousands of missed events. There are
3 options here:
 - Do no work and immediately red-highlight the room. Risk of false positives.
 - Grab the last N messages and see if any of them are highlights. **Current implementations using sync v2 do this.**
 - Grab all the missed messages and see if any of them are highlights. Denial of service risk if there are thousands of messages.

Once the highlight count has been adequately *estimated* (it's only truly calculated if you grab all
messages), this may affect the sort order for this room - it may diverge from that of the server.
More specifically, it may bump the room up or down the list, depending on what the sort
implementation is for E2EE rooms (top of list or below rooms with highlights).

Clients have two main choices here:
 - **Lite**: Keep E2EE rooms in the main list. This means the sort order won't always be strictly
   accurate for them but is fast to do. If you are sorting by highlight count then unread count
   (which is fairly typical) then E2EE rooms will always be bumped above all the unread count rooms
   if the resolution algorithm is set to "Assume `highlight_count == 1` whenever `unread_count > 0`".
 - **Heavy**: Sort E2EE rooms into a separate list. Manually mix together the E2EE list and the main
   list depending on highlight counts. This means the sort order will be more accurate but is slower
   and more complex to perform. This is why there is an `is_encrypted` filter on the room list parameters.

In the future, it may become impossible for servers to sort by room name due to E2EE. This proposal
has no suggestion on how to handle encrypted room names beyond hoping that homomorphic encryption
will allow sorting based on ciphertext: this is an active area of research in the computer science
field.

### Extensions
We anticipate that as more features land in Matrix, different kinds of data will also want to be synced
to clients. Sync v2 did not have any first-class support to opt-in to new data. Sliding Sync does have
support for this via "extensions". Extensions also allow this proposal to be broken up into more
manageable sections. Extensions are requested by the client in a dedicated `extensions` block:
```js
{
    "extensions": {
        "name_of_extension": { // sticky
            "enabled": true, // sticky
            "extension_arg": "value",
            "extension_arg_2": true
        }
    }
}
```
Extensions MUST have an `enabled` flag which defaults to `false`. If a client sends an unknown extension
name, the server MUST ignore it (or else backwards compatibility between servers is broken when a newer
client tries to communicate with an older server). Extension args may or may not be sticky, it
depends on the extension.

Extensions can leverage the data from the core API, notably which rooms are currently inside sliding
windows as well as which rooms are explicitly subscribed to.

In an effort to reduce the size of this proposal, extensions will be done in separate MSCs. There will
be extensions for:
 - To Device Messaging - [spec](https://spec.matrix.org/v1.1/client-server-api/#extensions-to-sync) [impl](https://github.com/matrix-org/sliding-sync/blob/main/sync3/extensions/todevice.go)
 - End-to-End Encryption - [spec](https://spec.matrix.org/v1.1/client-server-api/#extensions-to-sync-1) [impl](https://github.com/matrix-org/sliding-sync/blob/main/sync3/extensions/e2ee.go)
 - Ephemeral Events - typing notifications, receipts: [spec](https://spec.matrix.org/v1.1/client-server-api/#client-behaviour-4)
 - Presence - `presence` in sync v2: [spec](https://spec.matrix.org/v1.1/client-server-api/#get_matrixclientv3sync)
 - Account Data - `account_data` in sync v2: [spec](https://spec.matrix.org/v1.1/client-server-api/#get_matrixclientv3sync) [impl](https://github.com/matrix-org/sliding-sync/blob/main/sync3/extensions/account_data.go)

_Rationale: The name 'extensions' is inspired by the spec itself which refers to "Extensions to /sync"
multiple times. These additional bits of data are all generally outside the scope of the core room
graph and room list so are well-placed for being treated separately. Furthermore, it is possible to
make a meaningful client which only supports the core API and no extensions, as the core controls
the room list and ability to receive events and state in a room. For clients which don't do E2EE and
don't handle presence/typing/receipts/other metadata, they can simply work with this MSC alone and
in full. This is a good balance because it means this MSC alone is useful: it doesn't **require**
additional extensions in order for a basic Matrix client to be written._

#### Filter and Sort Extensions

In addition to extending the sync API by adding more data to the response, the sync API needs to include
additional sorting/filtering options. Clients may want to sort or filter the room list in more ways
than this MSC provides (e.g include historical rooms, include knocked rooms) in order to provide a
good UI/UX. This is officially supported in the following way:
 - Sorting: Define a sort string (namespaced by MSC number when in the MSC process) and define exactly
   how a comparator function should be defined (less, equal, greater than). Explain the room-specific
   data that is being operated on. This sort string can then appear in the `sort` array.
 - Filtering: Define a JSON object which represents the arguments for the filter. If there is only a
   single argument then the JSON object may be a JSON value e.g `true` or `"room search query"`. Define
   a filter key name (namespaced by MSC number when in the MSC process). This filter can then appear
   in the `filter` object.

Caveats: It is not possible to specify ascending/descending when specifying a sort option. Furthermore,
it is not possible to include AND/OR/NOT operators in filter operations (they are always AND'd). This
is by design at present in order to restrain the scope and complexity of this MSC. Introducing options
for these will scope creep this MSC into creating an entire query language like SQL or GraphQL. The
author wishes to see exactly what sorting/filtering extension MSCs are created in order to see if
expanding the scope of the core MSC to include these options is sensible or not. Furthermore, it's not
currently defined how servers should behave if they encounter a filter or sort operation they do not
recognise. If the server rejects the request with an HTTP 400 then that will break backwards
compatibility with new clients vs old servers. However, the client would be otherwise unaware that
only _some_ of the sort/filter operations have taken effect. We may need to include a "warnings"
section to indicate which sort/filter operations are unrecognised, allowing for some form of graceful
degradation of service.

# Potential issues

This is a very large change to the Client-Server API, which affects the core data flows for every
single client implementation. This means it will require a lot of work from client developers to
support this MSC, especially given in practice clients will need to support _both_ sliding sync
and `/sync`. This work will slow down adoption of sliding sync.

In addition, this API is more restrictive than sync v2 as not all data is returned to the client. It
is possible that some data flows which are possible in sync v2 will not be possible in sliding sync due
to sorting and filtering limitations such as but not limited to:
 - More complex sorting operations beyond recency/name/unread counts e.g by number of joined members.
 - More complex filtering operations such as showing DMs from users who are currently in the viewed
   space, dependent on some flag in user settings.
 - More complex display operations such as showing summed total notification counts in spaces.
 - More complex space operations such as handling orphaned rooms and traversal of subspaces.
 - More complex bot requirements like knowing all rooms which have a certain custom state event in it,
   such that the presence of a state event becomes a filter.

It is expected that some of these use cases **will be supported as this MSC is iterated upon**. However,
it is likely that some of these use cases will not be supported in this MSC, but may be supported via
use of an extension MSC where applicable. Unfortunately, there may be some data flows which are genuinely
impossible to perform due to limitations of server-side operations (e.g if the data is encrypted). In
this case, clients will be forced to pull in all E2EE rooms to perform their data flows, which, whilst
slow, should still perform better than sync v2.

This MSC alone won't meet the needs of the entire ecosystem in terms of sorting/filtering/data returned
to the client. Extensions are a crucial part of this MSC to clearly define how the sync API can expand
with changing requirements.

# Alternatives

There are two main alternatives to this proposal:
 - Do nothing and keep using sync v2 in its current shape. Attempt to make it run faster.
 - Factor out some obviously expensive bits from sync v2 (e.g receipts) but keep returning all rooms
   in the response i.e no paginated sync.

Both alternatives will still scale based on the number of joined rooms on the user's account. Effective
implementations may _delay_ long sync times but fundamentally won't _prevent_ long sync times, given
a sufficiently large account. The core assumption of this MSC is that user accounts will have 1000s
and 10,000s of rooms per account as metadata rooms continue to be added (VoIP conference rooms,
spaces, profiles-as-rooms, thread-per-room, etc). If this assumption is false and room counts remain
reasonably well bounded then this MSC may not be required.

# Security considerations

This API presents new ways to request data from the server which need appropriate authentication checks:
 - Room subscriptions: ensure the user is joined to the room ID in question.
 - Spaces filters: ensure the user is joined to the space room ID in question.
 - Timeline limits: ensure the user is allowed to see events as far back as they request (history visibility).

In addition, this API presents new ways for the server to filter/sort Matrix data, which may become
impossible if they are end-to-end encrypted:
 - Room names, user display names, canonical aliases. These events are used to calculate room display names.
 - State event types and state keys. These are used in `required_state` filters and if they are
   encrypted it won't be possible for servers to return those specific events.
 - Highlight and notification counts imply the ability to inspect the event on the server. This is not
   possible in E2EE rooms. This is covered somewhat in the "E2EE handling" section of this MSC. If a
   client decides to work out accurate counts for E2EE rooms then they must fetch _all missed events_
   in the room and decrypt them to work out the content. If there are 1000s of missed events this will
   cause a denial of service attack on this client as downloading and decrypting all the events are
   expensive operations.

Furthermore, this API presents new ways for malicious users to modify other clients:
 - Specifying bogus `origin_server_ts` values on events will cause those rooms to be moved appropriately
   when the sort operation is `by_recency`. A malicious user could hide a room by forcibly sending
   events with a low `origin_server_ts` value. Conversely, they could force a room to be always near
   the top of the list by forcibly sending events with a high `origin_server_ts`. Servers could mitigate
   this by bounding the `origin_server_ts` used to be +/- 5min of their own clock, whilst still sending
   the real `origin_server_ts` value in the event.
 - Subtly adjusting the events in the room could adjust the calculated room name to be inappropriate.
   For example, if the malicious user can engineer which hero's display names are used when calculating
   the room name (say by joining/leaving fake accounts) then it's possible for those names to advertise
   spam or spell out offensive words.

This API presents new ways for clients to request complex operations which runs the risk of denial
of service attacks:
 - Complex or pathological filter/sort options (especially via extensions) may degrade performance
   on the server and client. This may affect other users on the server.

# Unstable prefix

Whilst this in MSC review the HTTP path will be `/_matrix/client/unstable/org.matrix.msc3575/sync`
with the intention of this eventually becoming (confusingly) `/_matrix/client/v4/sync`. As this is a
brand new endpoint, no other keys or fields need prefixing.

# Dependencies

There are no MSCs required for the core functionality to be implemented. Servers and clients need to
be spaces-aware for spaces filters. Extension MSCs will depend on this MSC for their core functionality.

# Implementation state

[Proxy server](https://github.com/matrix-org/sliding-sync) (v0.4.0):
 - Sliding Window API:
    - [x] Operation support
    - [x] Required state with wildcards
    - [x] Timeline limits
    - [x] Calculated room names
    - [x] Highlight/notification counts
    - [ ] Joined and invited member counts
    - [x] Prev batch (token will cause duplicate events on /messages) 
    - Sorting:
      - [x] By recency
      - [x] By highlight count
      - [x] By notification count
      - [x] By name (no locale flag)
    - Filtering:
      * [x] `is_dm`
      * [x] `is_encrypted`
      * [x] `is_invite`
      * [ ] `resolve_tombstones`
      * [x] `spaces`
      * [x] `room_types` and `not_room_types`
      * [x] `room_name_like`
      * [x] `tags` and `not_tags`
 - [x] Room Subscription API
 - [ ] Notifications API (unspecced)
 - [ ] Bandwidth optimisations
 - [ ] E2EE highlight/notification count handling
 - Extensions:
    - [x] To-device: [impl](https://github.com/matrix-org/sync-v3/blob/main/sync3/extensions/todevice.go)
    - [x] E2EE: [impl](https://github.com/matrix-org/sync-v3/blob/main/sync3/extensions/e2ee.go)
    - [x] Account Data: [impl](https://github.com/matrix-org/sync-v3/blob/main/sync3/extensions/account_data.go)
    - [ ] Ephemeral Events
    - [ ] Presence

# Appendices

In order to aid implementations, a series of test cases are provided which demonstrate core functionality
of this MSC. The intention of these test cases is to provide a way to automatically verify compliance
with this MSC. As such, they are represented as a sequence of JSON objects. These test cases are not
exhaustive, and don't account for authentication via access tokens or handling multiple user accounts.
For brevity, only fields that concern sliding sync are included in event descriptions.

TODO: once the API has stabilised
